import { Injectable } from '@angular/core';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { ScanResponseDTO } from '../../../interface/scan_interface';
import { SecurityMetrics, OwaspCategory, HotSecurityIssue } from '../../../interface/security_interface';

export interface PdfReportContext {
    projectName: string;
    dateFrom: string;
    dateTo: string;
    scans: ScanResponseDTO[];
    issues: any[];
    securityData?: {
        metrics: SecurityMetrics;
        owaspCoverage: OwaspCategory[];
        hotIssues: HotSecurityIssue[];
    };
    selectedSections: {
        qualityGate: boolean;
        issueBreakdown: boolean;
        securityAnalysis: boolean;
        technicalDebt?: boolean;
        trendAnalysis?: boolean;
        recommendations?: boolean;
    };
    recommendationsData?: any[];
    generatedBy?: string;
}

@Injectable({
    providedIn: 'root'
})
export class PdfService {

    generatePdf(context: PdfReportContext) {
        const pdf = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4',
        });

        const margin = 12;
        let y = 15;

        y = this.addHeader(pdf, context, margin, y);

        if (context.selectedSections.qualityGate) {
            y = this.addQualityGateSection(pdf, context.scans, margin, y);
        }

        if (context.selectedSections.issueBreakdown) {
            y = this.addIssueBreakdownSection(pdf, context.issues, margin, y);
        }
        if (context.selectedSections.securityAnalysis && context.securityData) {
            y = this.addSecuritySection(pdf, context.securityData, margin, y);
        }

        if (context.selectedSections.recommendations && context.recommendationsData) {
            y = this.addRecommendationsSection(pdf, context.recommendationsData, margin, y);
        }

        this.addFooter(pdf);

        const fileName = `Report_${context.projectName}_${context.dateFrom}_to_${context.dateTo}.pdf`;
        pdf.save(fileName);
    }

    // Header
    private addHeader(pdf: jsPDF, context: PdfReportContext, margin: number, y: number): number {
        pdf.setFontSize(20);
        pdf.setTextColor(33, 37, 41);
        pdf.text('Code Review Report', pdf.internal.pageSize.getWidth() / 2, y, { align: 'center' });
        y += 10;

        pdf.setFontSize(14);
        pdf.setTextColor(100);
        pdf.text(`Project: ${context.projectName}`, pdf.internal.pageSize.getWidth() / 2, y, { align: 'center' });
        y += 10;

        const today = new Date();
        const username = context.generatedBy || 'Unknown User';

        pdf.setFontSize(10);
        pdf.setTextColor(85, 85, 85);
        pdf.text(`Generated Date: ${today.toLocaleDateString()}`, margin, y);
        pdf.text(`Date Range: ${context.dateFrom} to ${context.dateTo}`, margin, y + 5);
        pdf.text(`Generated By: ${username}`, pdf.internal.pageSize.getWidth() - margin, y, { align: 'right' });
        y += 15;

        pdf.setDrawColor(200);
        pdf.setLineWidth(0.5);
        pdf.line(margin, y, pdf.internal.pageSize.getWidth() - margin, y);
        y += 10;

        return y;
    }

    // Quality Gate Summary
    private addQualityGateSection(pdf: jsPDF, scans: ScanResponseDTO[], margin: number, startY: number): number {
        let y = startY;

        const passedCount = scans.filter(s => ['SUCCESS', 'PASSED', 'OK'].includes((s.status || '').toUpperCase())).length;
        const failedCount = scans.filter(s => ['FAILED', 'ERROR', 'FAIL'].includes((s.status || '').toUpperCase())).length;
        const totalScans = scans.length;

        pdf.setFontSize(16);
        pdf.setTextColor(0, 123, 255);
        pdf.text('Quality Gate Summary', margin, y);
        y += 8;

        pdf.setFontSize(12);
        pdf.setTextColor(0);
        pdf.text(`Total Scans: ${totalScans}`, margin, y);
        y += 6;
        pdf.setTextColor(40, 167, 69);
        pdf.text(`Passed: ${passedCount}`, margin, y);
        y += 6;
        pdf.setTextColor(220, 53, 69);
        pdf.text(`Failed: ${failedCount}`, margin, y);
        y += 10;

        pdf.setFontSize(14);
        pdf.setTextColor(0, 123, 255);
        pdf.text('Scan History', margin, y);
        y += 5;

        const columns = [
            'Scan Date',
            'Status',
            'Quality Gate',
            'Reliability',
            'Security',
            'Maintain-\nability',
            'Bugs',
            'Vulnerabilities',
            'Code Smells'
        ];

        const rows = scans.map(s => {
            const dateObj = s.startedAt ? new Date(s.startedAt) : null;
            const dateStr = dateObj ? dateObj.toLocaleDateString('en-GB') : ''; // dd/mm/yyyy
            const timeStr = dateObj ? dateObj.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }) : ''; // HH:mm
            const formattedDate = dateObj ? `${dateStr}, ${timeStr}` : 'N/A';

            const qgRaw = (s.qualityGate || '').toUpperCase();
            const qgDisplay = qgRaw === 'OK' || qgRaw === 'PASSED' ? 'Pass' : (qgRaw === 'ERROR' || qgRaw === 'FAILED' ? 'Fail' : qgRaw);

            return [
                formattedDate,
                s.status || 'N/A',
                qgDisplay,
                s.metrics?.reliabilityRating || '-',
                s.metrics?.securityRating || '-',
                s.metrics?.maintainabilityRating || '-',
                s.metrics?.bugs ?? 0,
                s.metrics?.vulnerabilities ?? 0,
                s.metrics?.codeSmells ?? 0
            ];
        });

        (autoTable as any)(pdf, {
            head: [columns],
            body: rows,
            startY: y,
            theme: 'grid',
            headStyles: {
                fillColor: [255, 255, 255],
                textColor: 0,
                halign: 'left',
                lineWidth: 0.1,
                lineColor: [200, 200, 200]
            },
            bodyStyles: {
                textColor: 50,
                lineWidth: 0.1,
                lineColor: [200, 200, 200]
            },
            columnStyles: {
                0: { cellWidth: 35 }, // Date
                1: { cellWidth: 22 }, // Status
                2: { cellWidth: 17 }, // QG
                3: { cellWidth: 20, halign: 'center' }, // Rel
                4: { cellWidth: 18, halign: 'center' }, // Sec
                5: { cellWidth: 25, halign: 'center' }, // Main
                6: { halign: 'center' }, // Bugs
                7: { cellWidth: 18, halign: 'center' }, // Vulns
                8: { halign: 'center' }  // Smells
            },
            margin: { left: margin, right: margin }
        });

        return (pdf as any).lastAutoTable?.finalY ? (pdf as any).lastAutoTable.finalY + 10 : y + 50;
    }

    // IssueBreakdownSection
    private addIssueBreakdownSection(pdf: jsPDF, issues: any[], margin: number, startY: number): number {
        let y = startY;

        if (y > 250) {
            pdf.addPage();
            y = 15;
        }

        pdf.setFontSize(16);
        pdf.setTextColor(0, 123, 255);
        pdf.text('Issue Breakdown', margin, y);
        y += 6;

        pdf.setFontSize(10);
        pdf.setTextColor(100);
        pdf.text('Showing only Bugs and Vulnerabilities.', margin, y);
        y += 6;

        const columns = ['Type', 'Severity', 'Message'];

        const rows = issues.length > 0 ? issues.map(issue => {
            let type = (issue.type || '').toLowerCase();
            if (type === 'bug') type = 'Bug';
            if (type === 'vulnerability') type = 'Vulnerability';
            if (type === 'code_smell') type = 'Code Smell';

            return [
                type,
                issue.severity || '-',
                issue.message || '-'
            ];
        }) : [['No issues found matching criteria', '-', '-']];

        (autoTable as any)(pdf, {
            head: [columns],
            body: rows,
            startY: y,
            theme: 'grid',
            headStyles: {
                fillColor: [220, 53, 69],
                textColor: 255,
                halign: 'left'
            },
            bodyStyles: { textColor: 50 },
            columnStyles: {
                0: { cellWidth: 25 },
                1: { cellWidth: 20 },
                2: { cellWidth: 'auto' }
            },
            margin: { left: margin, right: margin }
        });

        return (pdf as any).lastAutoTable?.finalY ? (pdf as any).lastAutoTable.finalY + 10 : y + 30;
    }

    // SecurityAnalysisSection
    private addSecuritySection(pdf: jsPDF, securityData: NonNullable<PdfReportContext['securityData']>, margin: number, startY: number): number {
        let y = startY;
        const { metrics, owaspCoverage, hotIssues } = securityData;
        if (y > 200) {
            pdf.addPage();
            y = 15;
        }

        pdf.setFontSize(16);
        pdf.setTextColor(0, 123, 255);
        pdf.text('Security Analysis', margin, y);
        y += 10;

        pdf.setFontSize(12);
        pdf.setTextColor(0);
        pdf.text('Vulnerability Severity:', margin, y);
        y += 6;

        const vulnRows = metrics.vulnerabilities.map(v => [v.severity, String(v.count)]);

        (autoTable as any)(pdf, {
            head: [['Severity', 'Count']],
            body: vulnRows.length > 0 ? vulnRows : [['No vulnerabilities', '0']],
            startY: y,
            theme: 'striped',
            headStyles: { fillColor: [255, 193, 7], textColor: 0 }, // Yellow for security
            margin: { left: margin, right: margin },
            tableWidth: 80
        });

        y = (pdf as any).lastAutoTable?.finalY ? (pdf as any).lastAutoTable.finalY + 10 : y + 30;

        pdf.setFontSize(12);
        pdf.setTextColor(0);
        pdf.text('Top 5 Security Hotspots:', margin, y);
        y += 6;

        const top5 = hotIssues.slice(0, 5);
        const hotRows = top5.length > 0 ? top5.map(h => [h.name, String(h.count)]) : [['No hotspots detected', '-']];

        (autoTable as any)(pdf, {
            head: [['Issue', 'Count']],
            body: hotRows,
            startY: y,
            theme: 'striped',
            headStyles: { fillColor: [255, 87, 34], textColor: 255 }, // Orange for hotspots
            margin: { left: margin, right: margin },
            tableWidth: 120
        });

        y = (pdf as any).lastAutoTable?.finalY ? (pdf as any).lastAutoTable.finalY + 10 : y + 30;

        if (y > 200) {
            pdf.addPage();
            y = 15;
        }

        pdf.setFontSize(12);
        pdf.setTextColor(0);
        pdf.text('OWASP Top 10 Breakdown:', margin, y);
        y += 6;

        const owaspRows = owaspCoverage.map(owasp => {
            const statusText = owasp.status === 'pass' ? 'Pass' : owasp.status === 'warning' ? 'Warning' : 'Fail';
            return [owasp.name, String(owasp.count), statusText];
        });

        (autoTable as any)(pdf, {
            head: [['Category', 'Issue Count', 'Status']],
            body: owaspRows.length > 0 ? owaspRows : [['No OWASP data', '-', '-']],
            startY: y,
            theme: 'grid',
            headStyles: { fillColor: [0, 123, 255], textColor: 255 },
            bodyStyles: { textColor: 50 },
            margin: { left: margin, right: margin }
        });

        return (pdf as any).lastAutoTable?.finalY ? (pdf as any).lastAutoTable.finalY + 10 : y + 50;
    }

    private addFooter(pdf: jsPDF) {
        const pageCount = pdf.getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
            pdf.setPage(i);
            const pageHeight = pdf.internal.pageSize.height;
            pdf.setFontSize(8);
            pdf.setTextColor(150);
            pdf.text(
                'Generated automatically by PCCTH Automate Code Review',
                pdf.internal.pageSize.getWidth() / 2,
                pageHeight - 10,
                { align: 'center' }
            );
            pdf.text(
                `Page ${i} of ${pageCount}`,
                pdf.internal.pageSize.getWidth() - 12,
                pageHeight - 10,
                { align: 'right' }
            );
        }
    }

    private formatScanDate(date: string | undefined): string {
        if (!date) return 'N/A';
        const dateObj = new Date(date);
        const dateStr = dateObj.toLocaleDateString('en-GB'); // dd/mm/yyyy
        const timeStr = dateObj.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }); // HH:mm
        return `${dateStr}, ${timeStr}`;
    }

    private formatRating(value: string | number | undefined): string {
        if (value === null || value === undefined || value === '') return 'N/A';
        const s = String(value);
        if (s.startsWith('1')) return 'A';
        if (s.startsWith('2')) return 'B';
        if (s.startsWith('3')) return 'C';
        if (s.startsWith('4')) return 'D';
        if (s.startsWith('5')) return 'E';
        if (/^[A-E]$/i.test(s)) return s.toUpperCase();
        if (s === 'OK') return 'A';
        return s;
    }
    private addRecommendationsSection(pdf: jsPDF, recommendations: any[], margin: number, startY: number): number {
        if (startY > 250) {
            pdf.addPage();
            startY = 20;
        } else {
            startY += 10;
        }

        pdf.setFontSize(16);
        pdf.setTextColor(46, 125, 50); // Green color
        pdf.text('Recommendations', margin, startY);
        startY += 8;

        if (!recommendations || recommendations.length === 0) {
            pdf.setFontSize(10);
            pdf.setTextColor(0, 0, 0);
            pdf.text('No recommendations available.', margin, startY);
            return startY + 10;
        }

        const tableBody = recommendations.slice(0, 10).map(rec => [
            rec.severity,
            rec.type,
            rec.message,
            rec.recommendedFix
        ]);

        autoTable(pdf, {
            startY: startY,
            head: [['Severity', 'Type', 'Issue', 'Recommended Fix']],
            body: tableBody,
            margin: { left: margin, right: margin },
            headStyles: { fillColor: [76, 175, 80] }, // Green header
            styles: { fontSize: 8, cellPadding: 2 },
            columnStyles: {
                0: { cellWidth: 25 },
                1: { cellWidth: 25 },
                2: { cellWidth: 60 },
                3: { cellWidth: 'auto' }
            }
        });

        return (pdf as any).lastAutoTable.finalY + 10;
    }
}
